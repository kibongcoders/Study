Scalar 언어로 된 오픈 소스 메시지 브로커 프로젝트이고 이벤트 드리븐 아키텍처와 스트림 데이터 파이프라인이다.

## 카프카 발생 배경

개발에 시간이 지날수록 아키텍처와 어플리케이션의 개수가 많아짐 -> [[MSA]]
소스 어플리케이션과 타깃 어플리케이션을 연결하는 파이프라인 개수가 많아지고 타깃 어플리케이션의 영향이 소스 어플리케이션에 미침

다양한 메시징 플랫폼과 ETL(Extract Transfom Load)툴을 적용하여 아키텍처를 변경하려고 하였지만 복잡도가 상승

링크드인의 데이터팀은 신규 시스템을 만들게 되는데 이것이 아파치 카프카이다.

카프카는 각각의 어플리케이션끼리 연결하는 것이 아닌 한 곳에 모아 처리할 수 있도록 중앙집중화하였고 이를 통해 대용량 데이터를 수집하고 사용자들이 실시간 스트림으로 소비할 수 있도록 변경되었다.

## 카프카가 데이터 파이프라인으로 적합한 이유
- 높은 처리량 : 카프카는 보내고 받을 때 데이터를 묶어서 보내기 때문에 네트워크 통신 횟수를 최소한으로 줄여 동일 시간에 많은 데이터를 전송할 수 있다. (실시간 로그데이터를 처리하는데 적합) 
    또한 동일 목적의 데이터를 여러 파티션에 분배하고 데이터를 병렬 처리할 수 있다. -> 파티션 개   수만큼 컨슈머 개수를 늘려서 동일 시간 데이터 처리량을 늘린다.
- 확장성 : 데이터 파이프라인에서 데이터를 모을 때 데이터가 얼마나 들어올지 예측하기 어려움 -> 카프카는 가변적인 환경에서 안정적으로 확장이 가능 
    데이터가 적을 때에는 최소한 개수로 운영하다가 데이터가 많아지면 브로커의 개수를 늘린다. (Scale-Out)




여기서 메시지 브로커란
특정한 리소스에서 다른 쪽에 있는 리소스 또는 서비스 시스템으로 메시지를 전달할 때 사용되는 서버

즉 메세지를 전달시켜주는 역활을 하는 것이 메세지 서버, 메시지 브로커라고 보면 된다.

Producer/Consumer 분리 할 수 있다.

3개 이상의 브로커를 가지고 있는 클러스터링 구조 구성
브로커의 문제가 생겼을 경우 다른 브로커를 사용할 수 있어서 안전하게 메시지를 계속해서 사용할 수 있게 된다.

그리고 서버의 상태나, 서버의 리더, 문제에 대한 장애를 관리해주기 위한 코디네이터 시스템인 주키퍼를 같이 연동해서 사용하는 것이 일반적이다.

일반적인 사용방법
카프카 클라이언트

카프카에는 세가지가 존재한다.
Producer, Kafka Broker, Consumer

Producer : Broker에 데이터를 보내는 역활
Consumer  : Broker에 적재 되어 있는 데이터를 가져오는 역활

데이터가 전달되고 적재 되는 과정에서 정상적으로 수행이 되고 있는지를 알기 위해
Producer는 Acknowledgement Consumer는 Offset commit으로 확인 하게된다.

데이터를 담는 Topic, Partition, Offset으로 잘 처리 되었는지 확인한다.

네트워크 장애로 Acknowledgement 장애가 있는 경우 다시 보내게 된다.
이과정에서 중복된 데이터가 적재될 수 있으므로 카프카는  중복된 적재를 막기 위해멱등성 프로듀서를 사용하게 된다.

멱등성 프로듀서(Idempotence Producer)
카프카 3.0부터는 기본적으로 true로 사용하게 된다.
멱등성 프로듀서는 기본적인 프로듀서와 다르게 레코드를 브로커로 전송할 때 PID(Producer unique Id)와 SEQ(Sequence Number)를 전송하게 된다.

브로커는 PID와 SEQ를 가지고 있다가 중복 적재 요청이 오면 이후에 요청된 중복 레코드는 적재하지 않는다.

비동기 프로듀서로 작업해야 제대로 이 멱등성 프로듀서를 사용할 수 있다.
Producer가 Broker에 데이터를 보낼 때 PID와 SEQ가 함께 가게 되는데 이를 통해 중복을 피하게 된다.

Topic to Topic
변경이 되지 않고 계속 추가되는 데이터
지속적으로 



카프카 메세지를 신뢰성 있게 전달 하려면
3가지를 지켜야한다.

정확히 한번 - 중복성 금지
적어도 한번, 
최대 한번 - 데이터 유실