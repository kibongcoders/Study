# 카프카 스트림즈

적재된 데이터를 상태기반 또는 비상태기반으로 실시간 변환 하여 다른 토픽에 적재하는 라이브러리

![스크린샷 2023-11-16 오전 1 06 59](https://github.com/kibongcoders/Study/assets/54662349/cfbba000-5841-4c6d-b8eb-b902333f7834)

카프카 스트림즈는 카프카에서 공식적으로 지원하는 라이브러리이다.
그렇기 때문에 카프카 클러스터와 완벽하게 호환되면서 스트림 처리에 필요한 기능들을 제공한다.

스트림즈 어플리케이션 또는 카프카 브로커의 장애가 발생하더라도 정확힌 한번은 할 수 있도록 장애 허용 시스템을 가지고 있어 안정성이 뛰어나다.

카프카 운영시 실시간 처리를 해야 하는 필요성이 있다면 카프카 스트림즈 어플리케이션을 개발하는 것을 1순위로 고려하는 것이 좋다.

스트림즈 어플리케이션은 내부적으로 스레드를 1개 이상 생성 가능, 스레드는 1개 이상의 태스크를 가진다.

태스크(task)는 스트림즈 어플리케이션의 데이터 처리 최소 단위

만약 3개의 파티션으로 이루어진 토픽을 처리하는 스트림즈 어플리케이션을 실행 -> 내부에 3개의 테스트가 생긴다.

컨슈머 그룹으로 이루어진 컨슈머 스레드를 여러개 실행하는 것과 비슷 -> 병렬처리를 하기 위해

실제 운영환경 에서는 장애가 발생하더라도 안정적으로 운영할 수 있도록 2개 이상의 서버로 구성하여 운영 -> 장애가 발생하더라도 안전하게 스트림 처리 가능

## 카프카 스트림즈 구조

카프카 스트림즈의 구조와 사용 방법을 알기 위해서는 토폴로지에 대하여 알아야 한다.

### 토폴로지

![스크린샷 2023-11-16 오전 1 12 21](https://github.com/kibongcoders/Study/assets/54662349/c5c8c473-2510-4552-bf5f-d5b178152a90)

2개 이상의 노드들과 선으로 이루어진 집합 링(ring)형, 트리(tree)형, 성(start)형이 있다.

![스크린샷 2023-11-16 오전 1 17 00](https://github.com/kibongcoders/Study/assets/54662349/6b470f85-f92e-41d0-b1bf-653e86255774)

카프카 스트림즈에서는 토폴로지를 이루는 노드를 하나의 프로세서라고 부르고 노드와 노드를 이은 선을 스트림이라고 부른다.

스트림은 토픽의 데이터를 뜻하는데 이는 프로듀서와 컨슈머의 레코드와 동일하다.

프로세서에는 소스 프로세서, 스트림 프로세서, 싱크 프로세서 3가지가 있다.

- 소스 프로세서 : 데이터를 처리하기 위해 최초로 선언해야하는 노드
  하나 이상의 토픽에서 데이터를 가져오는 역활
- 스트림 프로세서 : 다른 프로세서가 반환한 데이터를 처리하는 역활
  변환, 분기처리와 같은 로직이 데이터 처리의 일종이라고 볼 수 있다.
- 싱크 프로세서 : 데이터를 특정 카프카로 저장하는 역활
  카프카 스트림즈로 처리된 데이터의 최종 종착지

## 개발 방법

스트림즈DSL(Domain Specific Language)과 프로세서 API 2가지 방법으로 개발 가능

### 스트림즈DSL 

스트림 프로세싱에 쓰일 만한 다양한 기능들을 자체 API로 만들어 놓음
대부분의 경우 변환 로직을 어렵지 않게 개발 가능

만약 스트림즈 DSL에서 제공하지 않는 일부 기능들의 경우 프로세서 API를 사용하여 구현 가능

예시)
- 메시지 값을 기반으로 토픽 분기처리
- 지난 10분간 들어온 데이터의 개수 집계
- 토픽과 다른 토픽의 결합으로 새로운 데이터 생성

스트림즈DSL에는 레코드의 흐름을 추상화한 3가지 개념 KStream, KTable, GlobalKTable이 있다. -> 오직 스트림즈DSL 에서만 사용된다.

#### KStream

![스크린샷 2023-11-16 오전 1 25 21](https://github.com/kibongcoders/Study/assets/54662349/7d7c63ed-bc75-46fc-b89c-2ad63f0f7580)

레코드의 흐름을 표현한 것 메시지 키와 메시지 값으로 구성
KStream으로 데이터 조회 시 토픽에 존재하는(또는 KStream에 존재하는) 모든 레코드가 출력

#### KTable 

![스크린샷 2023-11-16 오전 1 29 19](https://github.com/kibongcoders/Study/assets/54662349/b4baffd2-403b-4c6f-9804-63f024ba18bb)

KStream과 다르게 메시지 키를 기준으로 묶어서 사용
유니크한 메시지 키를 기준으로 가장 최신 레코드를 사용 -> 가장 최신에 추가된 레코드의 데이터가 출력 된다. -> 동일한 메시지 키가 있을 경우 업데이트

#### GlobalKTable 

![스크린샷 2023-11-16 오전 2 00 321](https://github.com/kibongcoders/Study/assets/54662349/685f3679-81f0-4144-ae92-029b71abccdd)

KTable과 동일하게 메시지 키를 기준으로 묶어서 사용

KTable로 선언된 토픽은 1개의 파티션이 1개 태스크에 할당되어 사용
GlobalKTable로 선언된 토픽은 모든 파티션 데이터가 각 태스크에 할당 되어 사용된다는 차이점이 있음

이 차이점을 KStream과 KTable이 데이터 조인을 수행 할 때 가장 설명하기 좋다.

#### 주요 옵션

##### 필수 옵션
- bootstrap.server : 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커 호스트 이름:포트 를 1개 이상
- application.id : 어플리케이션을 구분하기 위한 고유한 아이디

##### 선택 옵션
- default.key.serde : 레코드의 메시지 키를 직렬화, 역직렬화하는 클래스를 지정 기본값은 바이트를 직렬화, 역직렬화 클래스인 Serdes.ByteArray().getClass().getName()
- num.stream.threads : 스트림 프로세싱 실행 시 실행될 스레드 개수 - 기본값 1
- state.dir : rocksDB 저장소가 위치할 디렉토리 -> rocksDB는 페이스북이 개발한 고성능 key-value DB 카프카 스트림즈가 상태기반 데이터를 처리를 할 때 로컬 저장소로 사용

#### stream(), to()

![스크린샷 2023-11-16 오전 1 45 32](https://github.com/kibongcoders/Study/assets/54662349/f9da7c83-2ca4-4685-baa4-a21f2f03fa09)

구현할 수 있는 가장 간단한 스트림 프로세싱은 특정 토픽의 데이터를 다른 토픽으로 전달하는 것
특정 토픽을 KStream 형태로 가져오려면 stream() 메서드를 사용
KStream의 데이터를 특정 토픽으로 저장하려면 to() 메서드를 사용

#### filter()

![스크린샷 2023-11-16 오전 1 48 52](https://github.com/kibongcoders/Study/assets/54662349/ba83a077-60aa-427a-8e7a-a4d0210118fd)

메시지 키 또는 메시지 값을 필터링하여 특정 조건에 맞는 데이터를 골라낼 때는 filter() 메서드를 사용하면 된다

#### KTable과 KStream을 join()

![스크린샷 2023-11-16 오전 1 52 09](https://github.com/kibongcoders/Study/assets/54662349/628db4cf-1f7a-4beb-8f3e-42db56c937b0)

KTable과 KStream을 메시지 키를 기준으로 조인할 수 있다. 

![스크린샷 2023-11-16 오전 1 53 06](https://github.com/kibongcoders/Study/assets/54662349/27d8a6fb-033e-4e36-9629-ad4ce080ac2a)

![스크린샷 2023-11-16 오전 1 54 13](https://github.com/kibongcoders/Study/assets/54662349/3c32c2e7-674a-410b-8c6a-ea1655e41223)

카프카 에서는 실시간으로 들어오는 데이터를 조인할 수 있다.
이를 통해 DB에 저장하지 않고도 조인하여 스트리밍 처리할 수 있다는 장점을 가지고 있다.
이벤트 기반 스트리밍 데이터 파이프라인을 구성할 수 있는 것이다.

#### GlobalKTable과 KStream을 join()

![스크린샷 2023-11-16 오전 2 04 53](https://github.com/kibongcoders/Study/assets/54662349/e2f86d87-46b4-4155-a1b9-74533e260f7a)

GlobalKTable과 KStream을 조인하는 경우에는 KTable과 KStream이 [[코파티셔닝]] 되어 있지 않은 토픽을 조인해야하는 경우에 사용된다.

![스크린샷 2023-11-16 오전 2 05 30](https://github.com/kibongcoders/Study/assets/54662349/fc3023e6-0271-4d75-85fc-5064ed7f20b9)

### 프로세서 API

스트림즈 DSL보다 투박한 코드를 가지지만 토폴로지를 기준으로 데이터를 처리한다는 관전에서 동일한 역활을 한다.
(KStream, KTable, GlobalKTable 개념은 없다는 점을 주의)

스트림즈 DSL에서 제공하지 않는 일부 기능들의 경우 프로세서 API를 사용하여 구현

예시)
- 메시지 값의 종류에 따라 토픽을 가변적으로 전송
- 일정한 시간 간격으로 데이터 처리](<# 카프카 스트림즈

적재된 데이터를 상태기반 또는 비상태기반으로 실시간 변환 하여 다른 토픽에 적재하는 라이브러리

![스크린샷 2023-11-16 오전 1 06 59](https://github.com/kibongcoders/Study/assets/54662349/cfbba000-5841-4c6d-b8eb-b902333f7834)

카프카 스트림즈는 카프카에서 공식적으로 지원하는 라이브러리이다.
그렇기 때문에 카프카 클러스터와 완벽하게 호환되면서 스트림 처리에 필요한 기능들을 제공한다.

스트림즈 어플리케이션 또는 카프카 브로커의 장애가 발생하더라도 정확힌 한번은 할 수 있도록 장애 허용 시스템을 가지고 있어 안정성이 뛰어나다.

카프카 운영시 실시간 처리를 해야 하는 필요성이 있다면 카프카 스트림즈 어플리케이션을 개발하는 것을 1순위로 고려하는 것이 좋다.

스트림즈 어플리케이션은 내부적으로 스레드를 1개 이상 생성 가능, 스레드는 1개 이상의 태스크를 가진다.

태스크(task)는 스트림즈 어플리케이션의 데이터 처리 최소 단위

만약 3개의 파티션으로 이루어진 토픽을 처리하는 스트림즈 어플리케이션을 실행 -%3E 내부에 3개의 테스트가 생긴다.

컨슈머 그룹으로 이루어진 컨슈머 스레드를 여러개 실행하는 것과 비슷 -> 병렬처리를 하기 위해

실제 운영환경 에서는 장애가 발생하더라도 안정적으로 운영할 수 있도록 2개 이상의 서버로 구성하여 운영 -> 장애가 발생하더라도 안전하게 스트림 처리 가능

## 카프카 스트림즈 구조

카프카 스트림즈의 구조와 사용 방법을 알기 위해서는 토폴로지에 대하여 알아야 한다.

### 토폴로지

![스크린샷 2023-11-16 오전 1 12 21](https://github.com/kibongcoders/Study/assets/54662349/c5c8c473-2510-4552-bf5f-d5b178152a90)

2개 이상의 노드들과 선으로 이루어진 집합 링(ring)형, 트리(tree)형, 성(start)형이 있다.

![스크린샷 2023-11-16 오전 1 17 00](https://github.com/kibongcoders/Study/assets/54662349/6b470f85-f92e-41d0-b1bf-653e86255774)

카프카 스트림즈에서는 토폴로지를 이루는 노드를 하나의 프로세서라고 부르고 노드와 노드를 이은 선을 스트림이라고 부른다.

스트림은 토픽의 데이터를 뜻하는데 이는 프로듀서와 컨슈머의 레코드와 동일하다.

프로세서에는 소스 프로세서, 스트림 프로세서, 싱크 프로세서 3가지가 있다.

- 소스 프로세서 : 데이터를 처리하기 위해 최초로 선언해야하는 노드
  하나 이상의 토픽에서 데이터를 가져오는 역활
- 스트림 프로세서 : 다른 프로세서가 반환한 데이터를 처리하는 역활
  변환, 분기처리와 같은 로직이 데이터 처리의 일종이라고 볼 수 있다.
- 싱크 프로세서 : 데이터를 특정 카프카로 저장하는 역활
  카프카 스트림즈로 처리된 데이터의 최종 종착지

## 개발 방법

스트림즈DSL(Domain Specific Language)과 프로세서 API 2가지 방법으로 개발 가능

### 스트림즈DSL 

스트림 프로세싱에 쓰일 만한 다양한 기능들을 자체 API로 만들어 놓음
대부분의 경우 변환 로직을 어렵지 않게 개발 가능

만약 스트림즈 DSL에서 제공하지 않는 일부 기능들의 경우 프로세서 API를 사용하여 구현 가능

예시)
- 메시지 값을 기반으로 토픽 분기처리
- 지난 10분간 들어온 데이터의 개수 집계
- 토픽과 다른 토픽의 결합으로 새로운 데이터 생성

스트림즈DSL에는 레코드의 흐름을 추상화한 3가지 개념 KStream, KTable, GlobalKTable이 있다. -> 오직 스트림즈DSL 에서만 사용된다.

#### KStream

![스크린샷 2023-11-16 오전 1 25 21](https://github.com/kibongcoders/Study/assets/54662349/7d7c63ed-bc75-46fc-b89c-2ad63f0f7580)

레코드의 흐름을 표현한 것 메시지 키와 메시지 값으로 구성
KStream으로 데이터 조회 시 토픽에 존재하는(또는 KStream에 존재하는) 모든 레코드가 출력

#### KTable 

![스크린샷 2023-11-16 오전 1 29 19](https://github.com/kibongcoders/Study/assets/54662349/b4baffd2-403b-4c6f-9804-63f024ba18bb)

KStream과 다르게 메시지 키를 기준으로 묶어서 사용
유니크한 메시지 키를 기준으로 가장 최신 레코드를 사용 -> 가장 최신에 추가된 레코드의 데이터가 출력 된다. -> 동일한 메시지 키가 있을 경우 업데이트

#### GlobalKTable 

![스크린샷 2023-11-16 오전 2 00 321](https://github.com/kibongcoders/Study/assets/54662349/685f3679-81f0-4144-ae92-029b71abccdd)

KTable과 동일하게 메시지 키를 기준으로 묶어서 사용

KTable로 선언된 토픽은 1개의 파티션이 1개 태스크에 할당되어 사용
GlobalKTable로 선언된 토픽은 모든 파티션 데이터가 각 태스크에 할당 되어 사용된다는 차이점이 있음

이 차이점을 KStream과 KTable이 데이터 조인을 수행 할 때 가장 설명하기 좋다.

#### 주요 옵션

##### 필수 옵션
- bootstrap.server : 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커 호스트 이름:포트 를 1개 이상
- application.id : 어플리케이션을 구분하기 위한 고유한 아이디

##### 선택 옵션
- default.key.serde : 레코드의 메시지 키를 직렬화, 역직렬화하는 클래스를 지정 기본값은 바이트를 직렬화, 역직렬화 클래스인 Serdes.ByteArray().getClass().getName()
- num.stream.threads : 스트림 프로세싱 실행 시 실행될 스레드 개수 - 기본값 1
- state.dir : rocksDB 저장소가 위치할 디렉토리 -> rocksDB는 페이스북이 개발한 고성능 key-value DB 카프카 스트림즈가 상태기반 데이터를 처리를 할 때 로컬 저장소로 사용

#### stream(), to()

![스크린샷 2023-11-16 오전 1 45 32](https://github.com/kibongcoders/Study/assets/54662349/f9da7c83-2ca4-4685-baa4-a21f2f03fa09)

구현할 수 있는 가장 간단한 스트림 프로세싱은 특정 토픽의 데이터를 다른 토픽으로 전달하는 것
특정 토픽을 KStream 형태로 가져오려면 stream() 메서드를 사용
KStream의 데이터를 특정 토픽으로 저장하려면 to() 메서드를 사용

#### filter()

![스크린샷 2023-11-16 오전 1 48 52](https://github.com/kibongcoders/Study/assets/54662349/ba83a077-60aa-427a-8e7a-a4d0210118fd)

메시지 키 또는 메시지 값을 필터링하여 특정 조건에 맞는 데이터를 골라낼 때는 filter() 메서드를 사용하면 된다

#### KTable과 KStream을 join()

![스크린샷 2023-11-16 오전 1 52 09](https://github.com/kibongcoders/Study/assets/54662349/628db4cf-1f7a-4beb-8f3e-42db56c937b0)

KTable과 KStream을 메시지 키를 기준으로 조인할 수 있다. 

![스크린샷 2023-11-16 오전 1 53 06](https://github.com/kibongcoders/Study/assets/54662349/27d8a6fb-033e-4e36-9629-ad4ce080ac2a)

![스크린샷 2023-11-16 오전 1 54 13](https://github.com/kibongcoders/Study/assets/54662349/3c32c2e7-674a-410b-8c6a-ea1655e41223)

카프카 에서는 실시간으로 들어오는 데이터를 조인할 수 있다.
이를 통해 DB에 저장하지 않고도 조인하여 스트리밍 처리할 수 있다는 장점을 가지고 있다.
이벤트 기반 스트리밍 데이터 파이프라인을 구성할 수 있는 것이다.

#### GlobalKTable과 KStream을 join()

![스크린샷 2023-11-16 오전 2 04 53](https://github.com/kibongcoders/Study/assets/54662349/e2f86d87-46b4-4155-a1b9-74533e260f7a)

GlobalKTable과 KStream을 조인하는 경우에는 KTable과 KStream이 코파티셔닝 되어 있지 않은 토픽을 조인해야하는 경우에 사용된다.

![스크린샷 2023-11-16 오전 2 05 30](https://github.com/kibongcoders/Study/assets/54662349/fc3023e6-0271-4d75-85fc-5064ed7f20b9)

### 프로세서 API

스트림즈 DSL에서 제공하지 않는 일부 기능들의 경우 프로세서 API를 사용하여 구현

예시)
- 메시지 값의 종류에 따라 토픽을 가변적으로 전송
- 일정한 시간 간격으로 데이터 처리>)](<# 카프카 스트림즈

적재된 데이터를 상태기반 또는 비상태기반으로 실시간 변환 하여 다른 토픽에 적재하는 라이브러리

![스크린샷 2023-11-16 오전 1 06 59](https://github.com/kibongcoders/Study/assets/54662349/cfbba000-5841-4c6d-b8eb-b902333f7834)

카프카 스트림즈는 카프카에서 공식적으로 지원하는 라이브러리이다.
그렇기 때문에 카프카 클러스터와 완벽하게 호환되면서 스트림 처리에 필요한 기능들을 제공한다.

스트림즈 어플리케이션 또는 카프카 브로커의 장애가 발생하더라도 정확힌 한번은 할 수 있도록 장애 허용 시스템을 가지고 있어 안정성이 뛰어나다.

카프카 운영시 실시간 처리를 해야 하는 필요성이 있다면 카프카 스트림즈 어플리케이션을 개발하는 것을 1순위로 고려하는 것이 좋다.

스트림즈 어플리케이션은 내부적으로 스레드를 1개 이상 생성 가능, 스레드는 1개 이상의 태스크를 가진다.

태스크(task)는 스트림즈 어플리케이션의 데이터 처리 최소 단위

만약 3개의 파티션으로 이루어진 토픽을 처리하는 스트림즈 어플리케이션을 실행 -%3E 내부에 3개의 테스트가 생긴다.

컨슈머 그룹으로 이루어진 컨슈머 스레드를 여러개 실행하는 것과 비슷 -> 병렬처리를 하기 위해

실제 운영환경 에서는 장애가 발생하더라도 안정적으로 운영할 수 있도록 2개 이상의 서버로 구성하여 운영 -> 장애가 발생하더라도 안전하게 스트림 처리 가능

## 카프카 스트림즈 구조

카프카 스트림즈의 구조와 사용 방법을 알기 위해서는 토폴로지에 대하여 알아야 한다.

### 토폴로지

![스크린샷 2023-11-16 오전 1 12 21](https://github.com/kibongcoders/Study/assets/54662349/c5c8c473-2510-4552-bf5f-d5b178152a90)

2개 이상의 노드들과 선으로 이루어진 집합 링(ring)형, 트리(tree)형, 성(start)형이 있다.

![스크린샷 2023-11-16 오전 1 17 00](https://github.com/kibongcoders/Study/assets/54662349/6b470f85-f92e-41d0-b1bf-653e86255774)

카프카 스트림즈에서는 토폴로지를 이루는 노드를 하나의 프로세서라고 부르고 노드와 노드를 이은 선을 스트림이라고 부른다.

스트림은 토픽의 데이터를 뜻하는데 이는 프로듀서와 컨슈머의 레코드와 동일하다.

프로세서에는 소스 프로세서, 스트림 프로세서, 싱크 프로세서 3가지가 있다.

- 소스 프로세서 : 데이터를 처리하기 위해 최초로 선언해야하는 노드
  하나 이상의 토픽에서 데이터를 가져오는 역활
- 스트림 프로세서 : 다른 프로세서가 반환한 데이터를 처리하는 역활
  변환, 분기처리와 같은 로직이 데이터 처리의 일종이라고 볼 수 있다.
- 싱크 프로세서 : 데이터를 특정 카프카로 저장하는 역활
  카프카 스트림즈로 처리된 데이터의 최종 종착지

## 개발 방법

스트림즈DSL(Domain Specific Language)과 프로세서 API 2가지 방법으로 개발 가능

### 스트림즈DSL 

스트림 프로세싱에 쓰일 만한 다양한 기능들을 자체 API로 만들어 놓음
대부분의 경우 변환 로직을 어렵지 않게 개발 가능

만약 스트림즈 DSL에서 제공하지 않는 일부 기능들의 경우 프로세서 API를 사용하여 구현 가능

예시)
- 메시지 값을 기반으로 토픽 분기처리
- 지난 10분간 들어온 데이터의 개수 집계
- 토픽과 다른 토픽의 결합으로 새로운 데이터 생성

스트림즈DSL에는 레코드의 흐름을 추상화한 3가지 개념 KStream, KTable, GlobalKTable이 있다. -> 오직 스트림즈DSL 에서만 사용된다.

#### KStream

![스크린샷 2023-11-16 오전 1 25 21](https://github.com/kibongcoders/Study/assets/54662349/7d7c63ed-bc75-46fc-b89c-2ad63f0f7580)

레코드의 흐름을 표현한 것 메시지 키와 메시지 값으로 구성
KStream으로 데이터 조회 시 토픽에 존재하는(또는 KStream에 존재하는) 모든 레코드가 출력

#### KTable 

![스크린샷 2023-11-16 오전 1 29 19](https://github.com/kibongcoders/Study/assets/54662349/b4baffd2-403b-4c6f-9804-63f024ba18bb)

KStream과 다르게 메시지 키를 기준으로 묶어서 사용
유니크한 메시지 키를 기준으로 가장 최신 레코드를 사용 -> 가장 최신에 추가된 레코드의 데이터가 출력 된다. -> 동일한 메시지 키가 있을 경우 업데이트

#### GlobalKTable 

![스크린샷 2023-11-16 오전 2 00 321](https://github.com/kibongcoders/Study/assets/54662349/685f3679-81f0-4144-ae92-029b71abccdd)

KTable과 동일하게 메시지 키를 기준으로 묶어서 사용

KTable로 선언된 토픽은 1개의 파티션이 1개 태스크에 할당되어 사용
GlobalKTable로 선언된 토픽은 모든 파티션 데이터가 각 태스크에 할당 되어 사용된다는 차이점이 있음

이 차이점을 KStream과 KTable이 데이터 조인을 수행 할 때 가장 설명하기 좋다.

#### 주요 옵션

##### 필수 옵션
- bootstrap.server : 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커 호스트 이름:포트 를 1개 이상
- application.id : 어플리케이션을 구분하기 위한 고유한 아이디

##### 선택 옵션
- default.key.serde : 레코드의 메시지 키를 직렬화, 역직렬화하는 클래스를 지정 기본값은 바이트를 직렬화, 역직렬화 클래스인 Serdes.ByteArray().getClass().getName()
- num.stream.threads : 스트림 프로세싱 실행 시 실행될 스레드 개수 - 기본값 1
- state.dir : rocksDB 저장소가 위치할 디렉토리 -> rocksDB는 페이스북이 개발한 고성능 key-value DB 카프카 스트림즈가 상태기반 데이터를 처리를 할 때 로컬 저장소로 사용

#### stream(), to()

![스크린샷 2023-11-16 오전 1 45 32](https://github.com/kibongcoders/Study/assets/54662349/f9da7c83-2ca4-4685-baa4-a21f2f03fa09)

구현할 수 있는 가장 간단한 스트림 프로세싱은 특정 토픽의 데이터를 다른 토픽으로 전달하는 것
특정 토픽을 KStream 형태로 가져오려면 stream() 메서드를 사용
KStream의 데이터를 특정 토픽으로 저장하려면 to() 메서드를 사용

#### filter()

![스크린샷 2023-11-16 오전 1 48 52](https://github.com/kibongcoders/Study/assets/54662349/ba83a077-60aa-427a-8e7a-a4d0210118fd)

메시지 키 또는 메시지 값을 필터링하여 특정 조건에 맞는 데이터를 골라낼 때는 filter() 메서드를 사용하면 된다

#### KTable과 KStream을 join()

![스크린샷 2023-11-16 오전 1 52 09](https://github.com/kibongcoders/Study/assets/54662349/628db4cf-1f7a-4beb-8f3e-42db56c937b0)

KTable과 KStream을 메시지 키를 기준으로 조인할 수 있다. 

![스크린샷 2023-11-16 오전 1 53 06](https://github.com/kibongcoders/Study/assets/54662349/27d8a6fb-033e-4e36-9629-ad4ce080ac2a)

![스크린샷 2023-11-16 오전 1 54 13](https://github.com/kibongcoders/Study/assets/54662349/3c32c2e7-674a-410b-8c6a-ea1655e41223)

카프카 에서는 실시간으로 들어오는 데이터를 조인할 수 있다.
이를 통해 DB에 저장하지 않고도 조인하여 스트리밍 처리할 수 있다는 장점을 가지고 있다.
이벤트 기반 스트리밍 데이터 파이프라인을 구성할 수 있는 것이다.

#### GlobalKTable과 KStream을 join()

![스크린샷 2023-11-16 오전 2 04 53](https://github.com/kibongcoders/Study/assets/54662349/e2f86d87-46b4-4155-a1b9-74533e260f7a)

GlobalKTable과 KStream을 조인하는 경우에는 KTable과 KStream이 코파티셔닝 되어 있지 않은 토픽을 조인해야하는 경우에 사용된다.

![스크린샷 2023-11-16 오전 2 05 30](https://github.com/kibongcoders/Study/assets/54662349/fc3023e6-0271-4d75-85fc-5064ed7f20b9)

### 프로세서 API

스트림즈 DSL에서 제공하지 않는 일부 기능들의 경우 프로세서 API를 사용하여 구현

예시)
- 메시지 값의 종류에 따라 토픽을 가변적으로 전송
- 일정한 시간 간격으로 데이터 처리>)