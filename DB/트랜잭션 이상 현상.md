트랜잭션이 동시에 실행 될 때 발생 될 수 있는 이상현상

## Dirty Read
**commit 되지 않은 변화를 읽을 때 발생되는 문제**

EX) r1(x,y) => 10,10, w2(y) => 80, r1(x,y > 80) , w1(x) => 90  ,c1, c2
c2에서 abort가 일어나게 되면 원래 y가 10이였다가 w2에서 변경된 값으로 조건을 만족했었므로
abort 하게 되면 y가 10으로 돌아가 조건을 만족하지 못하게 되었는데도 commit이 되어버려 데이터가 저장되어 버린다.

확장
EX) tx1 : x가 y에게 40을 이체, tx2 : x와 y를 읽음,  x = 50, y=50
r1(x), w1(x) => 10, r2(x) => 10, r2(y) => 50, c2, r1(y), w1(y) => 90, c1
해당 스케줄로 실행하게 된다면 tx2에서 x, y의 총합은 60이 되어 버리게 된다.
이는 데이터의 정합이 깨지게 되는 이상현상이 발생하게 된다.

## Non-Repeatable Read
**같은 데이터의 값이 달라짐**
Ex) r1(x) -> 10, r2(x) -> 10, w2(x) -> 50, c2, r1(x) -> 50, c1
해당 상황의 경우 처음 r1(x)에서는 10을 읽게 되고 두번째 r1(x) 50을 읽게 되어 같은 트랜잭션의 같은 데이터이지만 값이 다르게 읽는 이상현상이 일어나게 됨
트랜잭션의 Isolation 속성의 의해 한번 일어난것처럼 작동해야하는데 값이 달라짐

## Phantom Read
**없던 데이터가 생김**
EX) 데이터가 t1(v=10), t2(v=5) 가 있다고 할 때
r1(v=10) => t1, w2(t2.v=10), c2, r1(v=10) => t1, t2 , c1
원래 t2 조건을 만족하지 못했었으므로 t1만 읽을 수 있었지만 w2이후로 t2의 값이 변경되어 같은 조건이지만 없던 데이터이던 t2까지 읽는 이상현상이다.

확장

## Dirty Write
commit 안된 데이터를 write 함
w1(x) => 10, w2(x) => 100, c1 => abort 
이 상황에서 w1을 ROLLBACK 하게 되면 w1(x) 이전에 값으로 돌아가기 때문에 w2(x)가 실행되지 않은 것처럼 작동하게 된다.
그 때 c2 도 abort가 일어나게 되기 때문에 10으로 rollback하려고보면 이도저도 아닌 상황일 일어나게 된다.
모든 Isolation Level에서 허용되면 안된다.

## Lost Update
업데이트를 했는데 반영이 되지 않음 업데이트 덮어 씀
x=50, r1, r2(x), w2(x) => 200, c2, w1(x) => 100, c1
위 상태로 트랜잭션이 동작하게 되면 결국 x는 100이 되어 버린다. 이 과정에서 w2(x)가 동작되지 않은 것처럼 작동되는 이 현상을 Lost Update라고 부른다.

## Read Skew
데이터가 불일치한 읽기가 됨

EX) tx1 : x가 y에게 40을 이체, tx2 : x와 y를 읽음,  x = 50, y=50
r2(x), r1(x), w1(x) => 10, r1(y), w1(y) => 90, c1, r2(y), c2
해당 스케줄로 동작하게 된다면 tx2가 읽어내는 데이터는 x=50, y=90이 되어 버리게 된다. 이는 불일치한 데이터를 읽어들이게 되는 것이고 Non-Repeatable Read와 매우 유사하게 작동하게 된다.

## Write Skew
데이터 불일치한 쓰기

EX) tx1 : x에서 80을 인출, tx2 : y에서 90을 인출  x = 50, y=50, 제약 조건 : x+y >= 0
r1(x), r1(y), r2(x), r2(y), w1(x) => -30, w2(y) => -40, c1, c2
r1 에서 x와 y를 읽고 x에서 80만원을 인출해도 x+y가 20이므로 아무런 상관이 없다.
그리고 r2에서 x,y를 읽은 값으로 -90을 인출해도 제약조건에 위배되지는 않는다.
하지만 전부 놓고 보면 제약조건을 위반하는 현상이 일어나게 된다.

SNAPSHOT ISOLATION
