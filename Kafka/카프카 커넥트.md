# 카프카 커넥트


카프카 오픈소스에 포함된 툴 중 하나
데이터 파이프 라인 생성 시 반복 작업을 줄이고 효율적인 전송을 이루기 위한 어플리케이션

반복적인 파이프 라인 생성 작업이 있을 때 마다 프로듀서 컨슈머를 개발하고 배포 운영해야 하기 때문에 그것을 효율적으로 하기 위해 카프카 커넥트를 사용한다. 

커넥트는 특정한 작업 형태를 템플릿으로 만든 커넥터를 실행함으로써 반복 작업을 줄일 수 있다.

## 커넥터

커넥터는 이미 존재하는 카프카 플러그인들이 있다.
카프카 2.6에 포함된 커넥트를 실행할 경우 클러스터 간 토픽 미러링을 지우너하는 미러메이커 2커넥터와 파일 싱크 커넥터, 파일 소스 커넥터를 기본 플러그인으로 제공한다.

오픈소스 커넥터는 직접 커넥터를 만들 필요가 없고 커넥터 jar파일을 다운로드하여 사용할 수 있다.

### 커넥터 종류

커넥터 종류는 프로듀서 역활을 하는 소스 커넥터와 컨슈머 역활을 하는 싱크 커넥터 2가지로 나뉜다.

### 커넥터 생성 방법

사용자가 커넥트에 커넥터 생성 명령 -> 커넥트는 내부에 커넥터와 태스크 생성 -> 커넥터는 태스크들을 관리

사용자가 커넥터를 사용하여 파이프라인을 생성할 때 컨버터와 트랜스폼 기능을 옵션으로 추가할 수 있다. (반드시 필요한 설정은 아님)

- 컨버터 :  데이터 처리를 하기 전에 스키마를 변경하도록 도움
  JsonConverter, StringConverter, ByteArrayConverter
- 트랜스폼 : 데이터 처리 시 각 메시지 단위로 데이터를 간단하게 변환하기 위한 용도로 사용
  JSON을 커넥터에서 사용할 때 특정키를 삭제하거나 추가할 수 있다.


### 커넥트 실행하는 방법

커넥트를 실행하는 방법은 크게 2가지가 있다. 단일 모드 커넥트, 분산 모드 커넥트이다. 

그리고 REST API를 통해서 상태 확인을 할 수 있다.

#### 단일 모드 커넥트

단일 모드 커넥트는 1개 프로세스만 실행 되는 점이 특징
단일 프로세스로 실행되기 때문에 고가용성 구성이 되지 않음 -> 단일 장애점이 될 수 있다.
단일 모드 커넥트는 파이프라인은 주로 개발환경이나 중요도가 낮은 파이프라인을 운영할 때 사용

#### 분산 모드 커넥트

분산 모드 커넥트는 2대 이상의 서버에서 클러스터 형태로 운영
단일 모드 커넥트 대비 안정하게 운영할 수 있다는 장점
분산 모드 커넥트는 1개의 커넥트가 이슈 발생으로 중단 되더라도 1개의 커넥트가 파이프라인으로 지속적으로 처리할 수 있다.
그렇기 때문에 데이터 처리량의 변화에도 유연하게 대응할 수 있다.

이러한 장점 때문에 커넥트를 운영한다면 분산 모드 커넥트를 2대 이상으로 구성하고 설정하는 것이 좋다.

### 소스 커넥터

소스 어플리케이션 또는 소스 파일로 부터 데이터를 가져와 토픽으로 넣는 역활

플러그인을 사용할 수 도 있지만 요구사항과 맞지 않는 경우 커넥트 라이프러리에서 SourceConnector와 SourceTask 클래스를 사용하여 직접 소스 커넥ㅌ터를 구현하면 된다.

소스 커넥터를 만들 때는 connect-api 라이브러리를 추가해야한다.

- SourceConnector : 태스크를 실행하기 전 커넥터 설정파일을 초기화하고 어떤 태스크 클래스를 사용할 것인지 정의하는데 사용
  그렇기 때문에 실질적인 데이터를 다루는 부분이 들어가지 않는다. 
- SourceTask : 소스 어플리케이션 또는 소스 파일로 부터 데이터를 가져와서 토픽으로 데이터를 보내는 역활을 수행
  SourceTask 만의 자체적인 오프셋이 있어 데이터를 중복해서 토픽으로 보내는 것을 방지할 수 있다.

### 싱크 커넥터

싱크 커넥터는 토픽의 데이터를 타깃 어플리케이션 또는 타깃 파일로 저장하는 역활을 한다.

SinkConnector와 SinkTask 클래스를 사용하여 직접 싱크 커넥터를 구현할 수 있다.

또한 만들 때 connect-api 라이브러리를 추가해야한다.

 - SinkConnector :  태스크를 실행하기 전에 사용자로부터 입력받은 설정값을 초기화하고 어떤 태스크 클래스를 사용할 것인지 정의하는 데 사용
   실질 적인 처리 로직이 들어가지는 않는다.
- SinkTask : 커넥트에서 컨슈머 역활을 하고 데이터를 저장하는 코드를 가지게 된다.


## 카프카 미러메이커 2

서로 다른 두 개의 카프카 클러스터 간에 토픽을 복제하는 어플리케이션
토픽의 모든 것을 복제하여 사용할 때 사용 된다.

그리고 토픽의 데이터 복제 뿐만 아니라 토픽 설정까지도 복제하여 파티션의 변화, 토픽 설정값의 변화도 동기화 하는 기능을 가진다.

미러메이커 2는 카프카 클러스터가 2개 이상 있을 때 더욱 유용하게 사용할 수 있다.

### 액티브-스탠바이 클러스터 운영

재해 복구를 위해 임시 카프카 클러스터를 하나 더 구성하는 경우 액티브-스탠바이 클러스터로 운영할 수 있다.
이 때 서비스 어플리케이션들이 직접 통신하는 카프카 클러스트를 액티브 클러스터라고 부르고 나머지 1개 카프카 클러스터를 스탠바이 클러스터라고 부르고 나머지 1개 카프카 클러스터를 스탠바이 클러스터라고 부른다.
미러 메이커2를 사용하여 액티브 클러스터의 모든 토픽을 스탠바이 클러스터에 복제하여 액티브 클러스터의 예상치 못한 장애에 대응할 수 있다.

액티브-스탠바이 운영은 안정적으로 서버를 운영하기 위한 전통적인 방법이다.
각 클러스터 간의 구역을 완벽하게 분리함으로써 만에 하나 발생할 수 있는 액티브 클러스터의 장애에 대응할 수 있는 것이다.

#### 클러스터에 재해

클러스터에 재해가 일어나는 경우는 크게 3가지로 볼 수 있다.

1. 자연재해
2. 기술적 재해
   EMP 공격, 데이터 센터의 중단
3. 인간에 의한 재해
   사이버 공격, 사보타주

이러한 공격에 가장 좋은 방법은 물리적인 공간을 분리하는 것이다. 
이럴 때 액티브 클러스터는 한국에 두고 스탠바이 클러스터는 해외에 두어 운영하는 방식이 예가 될 수 있다.

이렇게 되면 한국에 있는 것이 재해에 의해 장애가 발생하더라도 복구할 수 있는 운영이 될 수 있다.

### 액티브-액티브 클러스터 운영

글로벌 서비스를 운영할 경우 서비스 어플리케이션의 통신 지연을 최소화 하기 위해 2개 이상의 클러스터를 두고 서로 데이터를 미러링하면서 사용할 수 있다.

물리적으로 아주 멀리 떨어진 곳에 있는 두 명의 유저의 데이터를 저장하고 사용하는 방법이다.
각 지역마다 클러스터를 두고 필요한 데이터만 복제해서 사용하는 방법

### 허브 앤 스포크 클러스터 운영

각 팀에서 소규모 카프카 클러스터를 사용하고 있을 때 각 팀의 카프카 클러스터의 데이터를 한개의 카프카 클러스터에 모아 데이터 레이크로 사용하고 싶을 때 사용

허브는 중앙에 있는 한개의 점을 뜻하고 스포크는 중앙의 점과 다른 점들을 연결한 선을 뜻한다.

여기서 허브가 데이터 레이크 용도의 카프카 클러스터를 뜻한다.

데이터 레이크 특성상 서비스에 생성된 데이터를 수집 가공 분석하는 격리된 플랫 폼이 필요하다.
