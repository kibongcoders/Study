# 코파티셔닝(co-partitioning)

조인을 하는 2개 데이터의 파티션 개수가 동일하고 파티셔닝 전략을 동일하게 맞추는 작업

파티션 개수가 동일하고 파티셔닝 전략이 같은 여우에는 동일한 메시지 키를 가진 데이터가 동일한 태스크에 들어가는 것을 보장

이를 통해 KStream의 레코드와 KTable의 메시지 키가 동일한 경우 조인을 수행할 수 있다.

![스크린샷 2023-11-16 오전 1 58 24](https://github.com/kibongcoders/Study/assets/54662349/142b92fb-c4c1-4722-bb69-d6e89e717811)

이때 문제는 조인을 수행하려는 토픽들이 코파티셔닝 되어 있음을 보장할 수 없다는 것인데

2개의 토픽의 파티션 개수가 다르고 파티션 전략이 다를 경우 KStream과 KTable로는 조인 할 수 없다. (TopologyException이 발생)

![스크린샷 2023-11-16 오전 1 58 27](https://github.com/kibongcoders/Study/assets/54662349/29849ec6-c0a9-4deb-a1e3-3ea47bec4fd8)

여기서는 2가지 방법을 할 수 있다.

1. 리파티셔닝
   새로운 토픽에 새로운 메시지 키를 가지도록 재배열 하는 과정
   코파티셔닝 되어 있지 않은 토픽을 항상 리파티셔닝 과정을 거쳐야 하고 기존의 데이터가 중복 생성 되고 재배열 까지 해야하는 과정이 생기는 문제점이 있다.
   
   ![스크린샷 2023-11-16 오전 2 00 39](https://github.com/kibongcoders/Study/assets/54662349/74cb0785-8bdf-4d1e-a83f-0437bc6e667d)

3. GlobalKTable과 KStream 조인
   GlobalKTable은 코파티셔닝 되어 있지 않은 KStream을 데이터 조인 할 수 있는데 그 이유는 GlobalKTable은 모든 태스크에 동일하게 공유되어 사용되기 때문
   다만 여기서 모든 데이터를 저장하고 사용하기 때문에 스트림즈 어플리케이션의 로컬 스토리지의 사용량이 증가하고 네크워크, 브로커에 부하가 생기므로 되도록 작은 용량의 데이터만 사용하는 것이 좋다.

   ![스크린샷 2023-11-16 오전 2 00 321](https://github.com/kibongcoders/Study/assets/54662349/685f3679-81f0-4144-ae92-029b71abccdd)

기억하자 작은용량 GlobalKTable과 KStream 조인 많은 양 리파티셔닝
