# 토픽

카프카를 사용하는 것은 토픽을 만들면서 시작된다.
이는 토픽을 잘 알고 사용하는 것이 카프카에 대한 활용도를 높이는 길

## 적정 파티션 개수

토픽의 파티션 개수는 카프카의 성능과 관련이 있다. 그렇기 때문에 토픽을 운영함에 있어 적절한 파티션 개수를 성정하고 운영하는 것이 매우 중요하다.

### 토픽 생성 시 파티션 개수 고려사항

- 데이터 처리량
- 메시지 키 사용 여부
- 브로커, 컨슈머 영향도

파티션은 카프카의 병렬처리 핵심
파티션의 개수가 많아지면 많아질수록 1:1 매핑되는 컨슈머 개수가 늘어나기 때문
그렇기 때문에 파티션 개수를 정할 때 해당 토픽에 필요한 데이터 처리량을 측정하여 정하는 것이 중요

데이터 처리 속도를 올리는 방법은 2가지다
- 컨슈머의 처리량을 늘리기
- 컨슈마를 추가해서 병렬처리량을 늘리기

컨슈머의 처리량을 늘릴려면 스케일 업하거나 GC 튜닝 등 활용할 수 있지만 일정 수준 이상 처리량을 올리는 것은 매우 어렵다.

하지만 컨슈머를 추가하는 방법은 데이터 처리량을 늘리는 가장 확실한 방법

프로듀서 < 컨슈머 데이터 처리량 X 최소 파티션 개수

파티션 개수만큼 컨슈머 스레드를 운영한다면 해당 토픽의 병렬처리를 극대화할 수 있다 만약 처리량이 데이터의 양보다 적다면 렉이 발생하게 될것이다.

처리량을 구하는 방법은 상용에서 운영 중인 카프카에서 더미 데이터로 테스트를 해보는 것
카프카 컨슈머를 개발할 때 내부 로직을 고민하여 시간 복잡도를 줄인다면 더욱 좋다.
하지만 카프카 클러스터와 다른 시스템등이 연결되어 있기 때문에 개발 환경과 운영환경의 데이터 처리량은 차이가 날 확률이 높다.

그렇기 때문에 상용환경에서 테스트를 권장
컨슈머 데이터 처리량을 구한 뒤 프로듀서가 보내는 데이터양을 하루,시간,분, 단위로 쪼개서 에측

그리고 지연이 발생 되어도 되느냐 아니면 발생되지 않아야하느냐로 데이터 생성량의 최대치를 계산할 수 있다.

그리고 파티션의 개수를 늘리는것도 능사는 아니다 파티션 개수를 늘리면 결국에는 컨슈머, 브로커에 부담이 된다. 그렇기 때문에 영향을 잘 고려하는것이 중요

## 토픽 정리 정책
토픽의 데이터는 시간 또는 용량에 따라 삭제 규칙을 적용할 수 있다. 
또는 삭제를 원치 않는다면 카프카 클러스터가 살아있는 한 토픽의 데이터를 삭제하지 않도록 설정할 수도 있다.
하지만 삭제를 하지 않으면 비용적으로 문제가 발생하게 된다.

cleanup.policy 옵션을 사용하여 데이터를 삭제할 수 있는데 옵션은 2가지이다.

### 토픽 삭제 정책 delete policy

일반적으로 대부분의 토픽의 cleanup.policy를 delete로 설정한다.
명시적으로 토픽의 데이터를 삭제하는 것을 뜻한다
토픽의 데이터를 삭제할 때는 세그먼트 단위로 삭제를 진행하게 되는데, 세그먼트는 명시적인 파일 시스템 단위이다.
세그먼트는 파티션마다 별개로 생성되며 세그먼트의 파일 이름은 오프셋 중 가장 작은 값이 된다.
세그먼트는 여러 조각으로 나뉘는데 segment.bytes 옵션으로 1개의 세그먼트 크기를 설정할 수 있다.
이 옵션의 크기보다 커질 경우 세그먼트 파일을 닫고 새로운 세그먼트를 열어서 데이터를 저장한다.
데이터를 저장하기 위해 사용 중인 세그먼트를 액티브 세그먼트라고 한다.

### 토픽 압축 정책 compact policy

여기서의 압축은 메시지 키별로 해당 메시지 키의 레코드 중 오래된 데이터를 삭제하는 정책을 뜻한다.
일반적인 삭제와 다르게 오프셋의 순서대로 삭제가 되지 않을 수 있다.

카프카 압축 정책은 스트림즈의 KTable과 같이 메시지 키를 기반으로 데이터를 처리할 경우 유용하다.

압축 정책은 액티브 세그먼트를 제외한 나머지 세그먼트들에 한해서만 데이터를 처리한다.
min.cleanable.dirty.ratio 옵션 값을 따른다.
이것은 더티와 클린의 비율 차이로 볼 수 있는데, 그림으로 보는 것이 더 좋다.

## ISR(In-Sync-Replicas)

ISR은 리더 파티션과 팔로우 파티션이 모두 싱크가 된 상태를 뜻한다.
이 말은 리더 파티션의 모든 데이터가 팔오워 파티션에 복제된 상태를 말한다.
리더 파티션과 팔로워 파티션이 동기화된 상태에서는 리더 또는 팔로워 파티션이 위치하는 브로커에 장애가 발생하더라도 데이터를 안전하게 사용할 수 있다.

ISR이라는 용어가 나오게 된 이유는 팔로워 파티션이 리더파티션으로부터 데이터를 복제하는 데에 시간이 걸리기 때문
이러한 시간차이를 모니터링하기 위해 replica.lag.time.max.ms 값 만큼의 주기를 가지고 팔로워 파티션이 데이터를 복제하는지 확인한다.
이보다 더 긴시간 동안 복제를 하지 않았다면 문제가 있는 줄 알고 ISR 그룹에서 제외한다.

팔로우 파티션에 데이터가 다 복제 되면 해당 팔로우 파티션은 리더 파티션으로 선출될 기회를 얻는다.
만약 리더 파티션이 문제가 될 경우 ISR인 팔로우 파티션이 리더 파티션으로 된다는 이야기이다.
하지만 unclean.leader.election.enable 이 true일 경우 ISR이 아닌 팔로우 파티션도 리더 파티션으로 선출 될 수 있다.

unclean.leader.election.enable을 false여야지만 데이터 유실을 막을 수 있어 되도록 이면 false로 두는것이 좋다.

