# 컨슈머

프로듀서 전송한 데이터는 카프카 브로커에 적재되고 컨슈머는 적재된 데이털르 사용하기 위해 브로커로 부터 데이터를 가져와서 처리를 하게 된다.

## 컨슈머 중요 개념

토픽의 파티션으로부터 데이터를 가져가기 위해 컨슈머를 운영하는 방법은 크게 2가지가 있다.

![스크린샷 2023-11-11 오후 9 09 28](https://github.com/kibongcoders/Study/assets/54662349/d74dd8ff-0d5f-45b0-8d5f-8c57932a33ff)


첫 번째 1개 이상의 컨슈머로 이루어진 컨슈머 그룹을 운영하는 것
두 번째는 토픽의 특정 파티션만 구독하는 컨슈머를 운영하는 것

### 컨슈머 그룹으로 운영하는 방법

컨슈머를 다른 컨슈머 그룹으로부터 격리된 환경에서 안정하게 운영할 수 있도록 도와주는 독특한 방식이다.

![스크린샷 2023-11-11 오후 9 09 38](https://github.com/kibongcoders/Study/assets/54662349/c682907f-a17f-44bc-9252-7ff7b897fdf9)

컨슈머 그룹의 컨슈머 개수는 가져가고자 하는 토픽의 파티션 개수보다 같거나 작아야한다 -> 놀고 있는 컨슈머가 생성될 수 있음

![스크린샷 2023-11-11 오후 9 13 35](https://github.com/kibongcoders/Study/assets/54662349/fc7cf07e-8d38-4c3d-ae24-62d82a23ace5)

엘라스틱서치에 저장에 문제가 생겨도 하둡에 저장되는 것에는 영향이 미치지 않도록 할 수 있다.

어디에 적재되고, 어떻게 처리되는지를 파악하고 컨슈머 그룹을 따로 나눌 수 있는 것은 최대한 나누는 것이 좋다.

#### 컨슈머 그룹의 장애가 발생되면 어떻게 될까?

해당 컨슈머에 장애가 발생하게 되면 장애가 할당된 파티션이 발생되지 않은 컨슈머로 소유권이 넘어가게 된다.

이것을 리밸런싱이라고 부른다

## Commit

#### 컨슈머는 어떻게 데이터를 어디까지 가져갔는지 알 수 있을까?

컨슈머는 commit을 통해 데이터를 어디까지 가져갔는지 기록한다.

![스크린샷 2023-11-15 오후 10 44 12](https://github.com/kibongcoders/Study/assets/54662349/5ba9898f-4f8e-4e12-b6bb-647fd7553f63)

어떤 컨슈머 그룹이 무엇을 가져갔는지 카프카 브로커 내부에서 사용되는 \_\_consumer_offsets
내부 토픽에 기록된다. 
만약 오프셋 커밋이 기록이 되지 못했다면 데이터 중복이 발생할 수 있다.

따라서 오프셋 커밋을 정상적으로 처리했는지 검증해야만 한다.

컨슈머 어플리케이션에서 명시적, 비명시적으로 수행 할 수 있는데

enable.auto.commit = true

- 비명시적 : 기본 옵션으로 poll() 메서드가 수행될 때 일정 간격마다 오프셋을 커밋
  auto.commit.interval.ms에 설정된 값으로 이 시간이 지났을 때 그 시점까지 읽은 레코드의 오프셋을 커밋한다.
  
  비명시적 오프셋 커밋은 편리하지만 리벨런싱 또는 컨슈머 강제종료 발생 시 데이터 중복 또는 유실이 발생될 수 있는 가능성이 있다.
  
- 명시적 : poll() 메서드 호출 이후 commitSync() 메서드를 호출하면 된다.
  poll() 메서드를 통해 반환된 레코드의 가장 마지막 오프셋을 기준으로  커밋을 수행한다.

내부에서 Fetcher 인스턴스가 생성 -> poll() 메서드를 호출

## 컨슈머 주요 옵션

### 필수 옵션

- bootstrap.servers : 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커의 호스트 이름:포트를 1개 이상 작성
- key.deserializer : 레코드의 메시지 키를 역직렬화하는 클래스 지정
- value.deserializer : 레코드의 메시지 값을 역직렬화하는 클래스를 지정

### 선택 옵션

- group.id : 컨슈머 그룹 아이디를 지정. subscribe() 메서드로 토픽을 구독하여 사용할 때는 이 옵션을 필수로 넣어야함
- auto.offset.reset : 컨슈머 그룹이 특정 파티션을 읽을 때 저장된 컨슈머 오프셋이 없는 경우 어느 오프셋부터 읽을지 선택하는 옵션
  이미 있다면 이 옵션은 무시
  latest, earliest, none 중에 하나로 설정 가능, latest - 가장 최근에 넣은 오프셋부터 읽기 시작, earliest - 가장 오래전에 넣은 것 부터 시작, none - 컨슈머 그룹이 커밋한 기록이 있는지 확인 후 없으면 오류 있으면 기록 이후부터 오프셋 읽기
  기본값은 latest
- enable.auto.commit : 자동 커밋, 수동 커밋 여부 선택 - 기본값 true
- auto.commit.interval.ms : 자동 커밋 일경우 오프셋간 커밋 간격
- max.poll.records : poll() 메서드를 통해 반환되는 레코드 개수 지정 - 기본값 500
- session.timeout.ms : 컨슈머와 브로커 연결 끊기는 최대 시간 이 시간 내에 하트비트를 전송 않하면 장애 발생으로 가정하고 리밸런싱 - 기본값 10000이다.
- hearbeat.interval.ms : 하트비트를 전송하는 시간 간격 - 기본값은 3000
- max.poll.interval.ms : poll() 메서드를 호출하는 간격의 최대 시간이다. 응답시간이 너무 오래 걸리는 경우 비정상으로 판단하고 리밸런싱 시작 - 기본값 300000(5분)
- isolation.level : 트랜잭션 프로듀서가 레코드를 트랜잭션 단위로 보낼 경우 사용
  read_committed, read_uncommitted으로 설정 - 기본값 read_uncommitted
  - read_committed : 커밋이 완료된 레코드만 읽는다.
  - read_uncommitted : 커밋 여부와 관계없이 파티션에 있는 모든 레코드를 읽는다.

## 리밸런스 리스너를 가진 컨슈머

컨슈머 그룹에서 컨슈머가 추가 또는 제거되면 파티션을 재할당한다.(리밸런스)

컨슈머가 데이터를 처리하기 전에 리밸런스가 발생하면 데이터를 중복 처리할 수 있다.
(일부 처리하였으나 commit 하지 않음)

리밸런스 발생시 처리한 데이터를 기준으로 커밋을 시도해야한다.
리밸런스 발생을 감지하기 위해 카프카 라이브러리는 ConsumerRebalanceListener 인터페이스를 지원

ConsumerRebalanceListener는 onPartitionAssigned() 메서드와 onPartitionRevoked() 메서드로 이루어져 있다.

onPartitionAssigned() 메서드는 리밸런스가 끝난 뒤에 파티션이 할당 완료되면 호출되는 메서드
onPartitionRevoked() 메서드는 리밸런스가 시작되기 직전에 호출되는 메서드

마지막으로 처리한 레코드를 기준으로 커밋을 하기 위해서는 리밸런스가 시작하기 직전에 커밋을 하면 되므로 onPartitionRevoked() 매서드에 커밋을 구현하여 처리 가능

## 파티션 할당 컨슈머

컨슈머를 운영할 때 subscribe() 메서드를 사용하지 않아도 직접 파티션을 컨슈머에 명시적으로 할당하여 운영할 수도 있다.