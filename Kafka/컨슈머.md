# 컨슈머

프로듀서 전송한 데이터는 카프카 브로커에 적재되고 컨슈머는 적재된 데이털르 사용하기 위해 브로커로 부터 데이터를 가져와서 처리를 하게 된다.

## 컨슈머 중요 개념

토픽의 파티션으로부터 데이터를 가져가기 위해 컨슈머를 운영하는 방법은 크게 2가지가 있다.

첫 번째 1개 이상의 컨슈머로 이루어진 컨슈머 그룹을 운영하는 것
두 번째는 토픽의 특정 파티션만 구독하는 컨슈머를 운영하는 것

### 컨슈머 그룹으로 운영하는 방법

컨슈머를 다른 컨슈머 그룹으로부터 격리된 환경에서 안정하게 운영할 수 있도록 도와주는 독특한 방식이다.

컨슈머 그룹의 컨슈머 개수는 가져가고자 하는 토픽의 파티션 개수보다 같거나 작아야한다 -> 놀고 있는 컨슈머가 생성될 수 있음

엘라스틱서치에 저장에 문제가 생겨도 하둡에 저장되는 것에는 영향이 미치지 않도록 할 수 있다.

어디에 적재되고, 어떻게 처리되는지를 파악하고 컨슈머 그룹을 따로 나눌 수 있는 것은 최대한 나누는 것이 좋다.

#### 컨슈머 그룹의 장애가 발생되면 어떻게 될까?

해당 컨슈머에 장애가 발생하게 되면 장애가 할당된 파티션이 발생되지 않은 컨슈머로 소유권이 넘어가게 된다.

이것을 리밸런싱이라고 부른다

### Commit

#### 컨슈머는 어떻게 데이터를 어디까지 가져갔는지 알 수 있을까?

컨슈머는 commit을 통해 데이터를 어디까지 가져갔는지 기록한다

어떤 컨슈머 그룹이 무엇을 가져갔는지 카프카 브로커 내부에서 사용되는 \_\_consumer_offsets
내부 토픽에 기록된다. 
만약 오프셋 커밋이 기록이 되지 못했다면 데이터 중복이 발생할 수 있다.

따라서 오프셋 커밋을 정상적으로 처리했는지 검증해야만 한다.

컨슈머 어플리케이션에서 명시적, 비명시적으로 수행 할 수 있는데

enable.auto.commit = true

- 비명시적 : 기본 옵션으로 poll() 메서드가 수행될 때 일정 간격마다 오프셋을 커밋
  auto.commit.interval.ms에 설정된 값으로 이 시간이 지났을 때 그 시점까지 읽은 레코드의 오프셋을 커밋한다.
  
  비명시적 오프셋 커밋은 편리하지만 리벨런싱 또는 컨슈머 강제종료 발생 시 데이터 중복 또는 유실이 발생될 수 있는 가능성이 있다.
  
- 명시적 : poll() 메서드 호출 이후 commitSync() 메서드를 호출하면 된다.
  poll() 메서드를 통해 반환된 레코드의 가장 마지막 오프셋을 기준으로  커밋을 수행한다.
- 
- 
- 
  
  
  




